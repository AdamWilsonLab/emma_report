{"title":"Park Report","markdown":{"yaml":{"title":"Park Report","params":{"focal_park_name":"Driftsands Nature Reserve"}},"headingText":"get focal park from yaml","containsRefs":false,"markdown":"\n\n\n```{r, echo=F, message = F, results = \"hide\"}\nlibrary(targets)\nlibrary(tidyverse)\nlibrary(doParallel)\n#library(raster)\nlibrary(lubridate)\nlibrary(sf)\nlibrary(xts)\nlibrary(plotly)\nlibrary(leaflet)\nlibrary(dygraphs)\nlibrary(terra)\nlibrary(cowplot)\nlibrary(ggridges)  \nlibrary(dygraphs)\nlibrary(mapview)\nlibrary(leafem)\nlibrary(SPEI)\n\n```\n\n```{r load_targets, echo=F, message=FALSE}\ntar_load(protected_areas)\n#tar_load(most_recent_fire.tif)\ntar_load(park_fire_history)\ntar_load(temp_directory)\ntar_load(years_since_fire.tif)\ntar_load(fires_wgs)\ntar_load(most_recent_ndvi.tif)\ntar_load(most_recent_ndvi_date)\ntar_load(monthly_mean_ndvi.tif)\ntar_load(monthly_delta_ndvi.tif)\ntar_load(weather_data)\n#tar_load(mean_ndvi.tif)\n#tar_load(delta_ndvi.tif)\n#tar_load(most_recent_quarter_ndvi_file)\n#tar_load(quarterly_delta_ndvi.tif)\ntar_load(stations)\ntar_load(inat_data)\n\n\ntime_window_days=365\n\n```\n\n\n```{r data_prep, echo = FALSE, warning = FALSE, message = FALSE,include=FALSE}\n\nfocal_park_name <- params$focal_park_name\n\n# set for testing\nif(F) focal_park_name <- \"Table Mountain National Park\"\n\n\nfocal_park=protected_areas |> \n  st_as_sf() |> \n  filter(name==focal_park_name)\n\n\n# CREATE wgs84 version of the park polygon\n\n    focal_park |> \n    st_transform(crs = st_crs(4326)) |> \n    st_make_valid() -> \n    focal_wgs\n\n# Create buffered fire age polygon\n\n    # make park-specific fire ages file\n      \n\n      fires_wgs %>%\n      st_crop(y = focal_wgs %>%\n                st_buffer(dist = 10000)) ->\n        focal_fires\n      \n      park_no_spaces <- gsub(pattern = \" \",replacement = \"_\",x = focal_park_name)\n\n      # focal_fires %>%\n      #   st_write(dsn = file.path(temp_directory, paste(park_no_spaces,\"fires.gpkg\",sep = \"_\")),\n      #            append=FALSE,\n      #            quiet = TRUE\n      #            )\n      # \n      # robust_pb_upload(file = file.path(temp_directory, paste(park_no_spaces,\"fires.gpkg\",sep = \"_\")),\n      #                  repo = \"AdamWilsonLab/emma_report\",\n      #                  tag = park_data_tag)\n      # \n      # file.remove(file.path(temp_directory, paste(park_no_spaces,\"fires.gpkg\",sep = \"_\")))\n      \n\n# Park-specific file link\n#    park_fires_file  <- paste(\"https://github.com/AdamWilsonLab/emma_report/releases/download/park_data/\",\n#                              paste(park_no_spaces,\"fires.gpkg\",sep= \"_\"),sep = \"\")\n\n# Create a truncated version of the fire maps (ranging from 1-20)\n\n  fires_wgs %>%\n    mutate(Years = case_when(Years > 20 ~ 20,\n                             Years <=20 ~ Years)) -> fires_wgs_truncated\n  \n\n\n#Note that the \"addLegend_decreasing\" isn't quite right, but might be close enough if you feel strongly about the ordering\n\naddLegend_decreasing <- function (map, position = c(\"topright\", \"bottomright\", \"bottomleft\", \n\t\t\t    \"topleft\"), pal, values, na.label = \"NA\", bins = 7, colors, \n\t\t  opacity = 0.5, labels = NULL, labFormat = labelFormat(), \n\t\t  title = NULL, className = \"info legend\", layerId = NULL, \n\t\t  group = NULL, data = getMapData(map), decreasing = FALSE) {\n\tposition <- match.arg(position)\n\ttype <- \"unknown\"\n\tna.color <- NULL\n\textra <- NULL\n\tif (!missing(pal)) {\n\t\tif (!missing(colors)) \n\t\t\tstop(\"You must provide either 'pal' or 'colors' (not both)\")\n\t\tif (missing(title) && inherits(values, \"formula\")) \n\t\t\ttitle <- deparse(values[[2]])\n\t\tvalues <- evalFormula(values, data)\n\t\ttype <- attr(pal, \"colorType\", exact = TRUE)\n\t\targs <- attr(pal, \"colorArgs\", exact = TRUE)\n\t\tna.color <- args$na.color\n\t\tif (!is.null(na.color) && col2rgb(na.color, alpha = TRUE)[[4]] == \n\t\t    0) {\n\t\t\tna.color <- NULL\n\t\t}\n\t\tif (type != \"numeric\" && !missing(bins)) \n\t\t\twarning(\"'bins' is ignored because the palette type is not numeric\")\n\t\tif (type == \"numeric\") {\n\t\t\tcuts <- if (length(bins) == 1) \n\t\t\t\tpretty(values, bins)\n\t\t\telse bins\t\n\t\t\t\n\t\t\tif (length(bins) > 2) \n\t\t\t\tif (!all(abs(diff(bins, differences = 2)) <= \n\t\t\t\t         sqrt(.Machine$double.eps))) \n\t\t\t\t\tstop(\"The vector of breaks 'bins' must be equally spaced\")\n\t\t\tn <- length(cuts)\n\t\t\tr <- range(values, na.rm = TRUE)\n\t\t\tcuts <- cuts[cuts >= r[1] & cuts <= r[2]]\n\t\t\tn <- length(cuts)\n\t\t\tp <- (cuts - r[1])/(r[2] - r[1])\n\t\t\textra <- list(p_1 = p[1], p_n = p[n])\n\t\t\tp <- c(\"\", paste0(100 * p, \"%\"), \"\")\n\t\t\tif (decreasing == TRUE){\n\t\t\t\tcolors <- pal(rev(c(r[1], cuts, r[2])))\n\t\t\t\tlabels <- rev(labFormat(type = \"numeric\", cuts))\n\t\t\t}else{\n\t\t\t\tcolors <- pal(c(r[1], cuts, r[2]))\n\t\t\t\tlabels <- rev(labFormat(type = \"numeric\", cuts))\n\t\t\t}\n\t\t\tcolors <- paste(colors, p, sep = \" \", collapse = \", \")\n\t\t\t\n\t\t}\n\t\telse if (type == \"bin\") {\n\t\t\tcuts <- args$bins\n\t\t\tn <- length(cuts)\n\t\t\tmids <- (cuts[-1] + cuts[-n])/2\n\t\t\tif (decreasing == TRUE){\n\t\t\t\tcolors <- pal(rev(mids))\n\t\t\t\tlabels <- rev(labFormat(type = \"bin\", cuts))\n\t\t\t}else{\n\t\t\t\tcolors <- pal(mids)\n\t\t\t\tlabels <- labFormat(type = \"bin\", cuts)\n\t\t\t}\n\t\t\t\n\t\t}\n\t\telse if (type == \"quantile\") {\n\t\t\tp <- args$probs\n\t\t\tn <- length(p)\n\t\t\tcuts <- quantile(values, probs = p, na.rm = TRUE)\n\t\t\tmids <- quantile(values, probs = (p[-1] + p[-n])/2, \n\t\t\t\t na.rm = TRUE)\n\t\t\tif (decreasing == TRUE){\n\t\t\t\tcolors <- pal(rev(mids))\n\t\t\t\tlabels <- rev(labFormat(type = \"quantile\", cuts, p))\n\t\t\t}else{\n\t\t\t\tcolors <- pal(mids)\n\t\t\t\tlabels <- labFormat(type = \"quantile\", cuts, p)\n\t\t\t}\n\t\t}\n\t\telse if (type == \"factor\") {\n\t\t\tv <- sort(unique(na.omit(values)))\n\t\t\tcolors <- pal(v)\n\t\t\tlabels <- labFormat(type = \"factor\", v)\n\t\t\tif (decreasing == TRUE){\n\t\t\t\tcolors <- pal(rev(v))\n\t\t\t\tlabels <- rev(labFormat(type = \"factor\", v))\n\t\t\t}else{\n\t\t\t\tcolors <- pal(v)\n\t\t\t\tlabels <- labFormat(type = \"factor\", v)\n\t\t\t}\n\t\t}\n\t\telse stop(\"Palette function not supported\")\n\t\tif (!any(is.na(values))) \n\t\t\tna.color <- NULL\n\t}\n\telse {\n\t\tif (length(colors) != length(labels)) \n\t\t\tstop(\"'colors' and 'labels' must be of the same length\")\n\t}\n\tlegend <- list(colors = I(unname(colors)), labels = I(unname(labels)), \n\t               na_color = na.color, na_label = na.label, opacity = opacity, \n\t               position = position, type = type, title = title, extra = extra, \n\t               layerId = layerId, className = className, group = group)\n\tinvokeMethod(map, data, \"addLegend\", legend)\n}\n\n\n# Create continuous palettes\n\n  pal <- colorNumeric(palette = \"Reds\",\n                      domain = fires_wgs_truncated$Years,\n                      reverse = TRUE)\n\n  antipal <- colorNumeric(palette = \"Reds\",\n                          domain = fires_wgs_truncated$Years,reverse = FALSE)\n  \n  \n  ndvi_pal <- colorNumeric(palette = c( \"#FFFFCC\", \"#41B6C4\",\"#0C2C84\"),\n                           #domain =  values(most_recent_ndvi.tif),\n                           domain =  c(-1,0,1),\n                           na.color = \"transparent\")\n  \n  #max_delta_ndvi <- max(abs(values(delta_ndvi.tif)),na.rm = TRUE)\n  max_delta_ndvi <- max(abs(values(monthly_delta_ndvi.tif)),na.rm = TRUE)\n  \n  delta_ndvi_pal <- colorNumeric(palette = c( \"brown\", \"white\",\"forestgreen\"),\n                                 #domain =  values(most_recent_ndvi.tif),\n                                 domain =  c(max_delta_ndvi*-1,max_delta_ndvi),\n                                 na.color = \"transparent\")\n\n  ndwi_pal <- colorNumeric(palette = c( \"#FFFFCC\", \"#41B6C4\",\"#0C2C84\"),\n                           #domain =  values(terra::rast(ndwi_rast)),\n                           domain = c(-1,1),\n                           na.color = \"transparent\")\n  \n  ndwi_bin_pal <- colorBin(palette = c( \"#FFFFCC\", \"#41B6C4\",\"#0C2C84\"),\n                           #domain =  values(terra::rast(ndwi_rast)),\n                           domain = c(-1,1),\n                           bins = c(-1,-.3,0.0,0.2,1),\n                           na.color = \"transparent\",\n                           alpha = TRUE)\n\n\n# Create bounding box for plotting  \n  \nbbox <- st_bbox(focal_wgs) %>%\n  as.vector()\n\n```\n\n```{r identify_closest_stations, echo = FALSE, warning = FALSE, message = FALSE}\n\n# Process the station and weather data\nn_stations=3 # number of stations to show\n  # Get data for closest weather stations\n  \n    cent <- suppressWarnings( focal_park %>%\n                                st_union()%>%\n                                st_centroid())\n    \n    closest_stations <- \n      data.frame(station = stations$STNID,\n                 name = stations$NAME,\n               distance = as.numeric(st_distance(cent,stations)))\n    \n    closest_stations <- closest_stations[order(closest_stations$distance),]\n    \n    closest_stations <- closest_stations$station[1:n_stations]\n    \n    # closest_stations %>%\n    #       gsub(pattern = \"/\",replacement = \"\",fixed = TRUE)%>% #what kind of sadist puts a slash in a name?\n    #       gsub(pattern = \" \",replacement = \"_\") %>%\n    #       gsub(pattern = \")\",replacement = \"_\",fixed = TRUE) %>%\n    #       gsub(pattern = \"(\",replacement = \"_\",fixed = TRUE) %>%\n    #       paste(.,\".gz.parquet\",sep = \"\")-> closest_stations\n    # \n\n    # robust_pb_download(file = closest_stations,\n    #             dest = temp_directory,\n    #             repo = \"AdamWilsonLab/emma_report\",\n    #             tag = \"GSOD\",\n    #             max_attempts = max_attempts,\n    #             sleep_time = sleep_time,\n    #             show_progress=FALSE) -> to_rm\n    # \n    # if(exists(\"to_rm\")){rm(to_rm)}\n    \n  #Hack in case some of the files aren't downloaded correctly.  \n    # closest_stations  <- intersect(closest_stations,\n    #                                list.files(temp_directory))\n\n    focal_weather=weather_data |> \n      filter(STNID%in%closest_stations)\n\n  if(nrow(focal_weather) < 1){stop(\"No weather data loaded\")}\n  \n```\n\n```{r reformat_to_match_noaa, echo = FALSE, warning = FALSE, message = FALSE}\n\n  #fix station names in focal weather (missing in many case)\n  \n    # stations %>%\n    # dplyr::select(usaf,wban,station_name)%>%\n    # inner_join(y = focal_weather,\n    #            by = c(\"usaf\"=\"usaf_station\",\"wban\"=\"wban_station\"),\n    #            multiple = \"all\")%>%\n    # dplyr::rename(station_name = station_name.x)-> focal_weather\n\n  #with dygraphs, first element should be x axis, or else do it as an xts\n  \n  # probably easiest to do xts, since its a time series anyway\n  \n  # focal_weather %>%\n  #   as.data.frame() %>% #for some reason, this code throws an error without this line.  no idea why.\n  #   mutate(year = substr(x = date,1,4),\n  #          month = substr(x = date,5,6),\n  #          day = substr(x=date,7,8),\n  #          hour= substr(x=time,1,2),\n  #          minute = substr(x=time,3,4)) %>%\n  #   mutate(date_time = paste(year,month,day,hour,minute,sep = \"-\"))%>%\n  #   mutate(date_time = strptime(date_time,format = \"%Y-%m-%d-%H-%M\"))%>%\n  #   dplyr::filter(!is.na(date_time)) -> focal_weather\n  \n  \n  #reformatting the GSOD to match NOAA format\n\n  focal_weather %>%\n    as.data.frame() %>%\n    dplyr::mutate(year = YEAR,\n                  month = MONTH,\n                  day = DAY,\n                  station_name = NAME,\n                  mean_precip_mm = PRCP,\n                  temp_c = TEMP) %>%\n    dplyr::mutate(date_time = paste(year,month,day,sep = \"-\")) %>%\n    dplyr::mutate(date_time = strptime(date_time,format = \"%Y-%m-%d\")) %>%\n    dplyr::filter(!is.na(date_time)) -> focal_weather\n\n```\n\n```{r filter_old_weather_data, echo = FALSE, warning = FALSE, message = FALSE}\n  \n  #Filter out oldest data\n  min_date = \"1970-01-01\"\n  focal_weather <- \n    focal_weather %>%\n    dplyr::filter(date_time > as_datetime(min_date,tz =tz(focal_weather$date_time)))\n\n```\n\n```{r generate_precip_dataset, echo = FALSE, warning = FALSE, message = FALSE}\n  \n  #Generate precip dataset\n  \n# focal_weather %>%\n#   group_by(station_name,year,month)%>%\n#   summarise(monthly_precip_mm = sum(na.omit(mean_precip_mm)))%>%\n#   ungroup() %>%\n#   mutate(date_time = paste(year,month,01,sep = \"-\"))%>%\n#   mutate(date_time = strptime(date_time,format = \"%Y-%m-%d\"))%>%\n#   mutate(date_time = lubridate::floor_date(date_time)-1)%>%\n#   dplyr::filter(!is.na(date_time))%>%\n#   dplyr::select(date_time,station_name, monthly_precip_mm) %>%\n#    filter(date_time>as_date(\"2000-01-01\")) |> \n#   pivot_wider(values_from = monthly_precip_mm,\n#               names_from = station_name,\n#               values_fn = mean) %>%\n#    mutate(doy =  lubridate::yday(date_time) ) %>%\n#    left_join(x=.,\n#              y  = group_by(., doy) %>%\n#                summarize(mean = mean(c_across(!contains(c(\"doy\",\"date_time\"))),\n#                                          na.rm=TRUE))\n#              ) %>%\n#  dplyr::select(-doy)%>%\n#   xts::xts(order.by = .$date_time) -> focal_precip\n  \n\nlibrary(zoo)\n# Set the rolling window size (must be odd for centering)\nwindow_size <- 61  # e.g., ±15 days = 31 total\n\n# Step 1: Prepare the daily data\nfocal_precip <- focal_weather %>%\n  filter(!is.na(mean_precip_mm)) %>%\n  select(station_name,date_time,mean_precip_mm) %>%\n  mutate(date_time = as_date(date_time)) %>%\n#  filter(date_time > as_date(\"2000-01-01\")) %>%\n  pivot_wider(\n    names_from = station_name,\n    values_from = mean_precip_mm,\n    values_fn = mean\n  ) %>%\n  mutate(doy = yday(date_time))\n\n# Step 2: Compute the daily climatology using all years\n# Average across stations by DOY\nfocal_precip_climatology <- focal_precip %>%\n  group_by(doy) %>%\n  summarise(clim_mean = mean(c_across(where(is.numeric)), na.rm = TRUE), .groups = \"drop\") %>%\n  arrange(doy)\n\n# Step 3: Apply rolling mean (wrap around to handle year start/end)\n# Pad the data for wrap-around\nextended <- bind_rows(\n  focal_precip_climatology %>% filter(doy > (366 - window_size)),\n  focal_precip_climatology,\n  focal_precip_climatology %>% filter(doy <= window_size)\n)\n\n# Compute the rolling mean twice to smooth it out\nextended$roll_mean <- zoo::rollmean(extended$clim_mean, k = window_size, fill = NA, align = \"center\") |> \n  zoo::rollmean(k = window_size, fill = NA, align = \"center\")\n\n# Step 4: Remove padding and match back to original DOY\nrolling_climatology <- extended %>%\n  slice((window_size + 1):(n() - window_size)) %>%\n  select(doy, mean = roll_mean)\n\n# Step 5: Join back to the daily weather data\nfocal_precip %>%\n  left_join(rolling_climatology, by = \"doy\") %>%\n  select(-doy) %>%\n   xts::xts(x=select(.,-date_time), order.by = .$date_time) -> focal_precip\n\n\n# calculate monthly totals\n  bind_cols(date_time=time(focal_precip),as.data.frame(focal_precip)) |> \n    mutate(year=year(as_date(date_time)),month=month(as_date(date_time))) |> \n    pivot_longer(-c(date_time,month,year),names_to=\"station\",values_to=\"precip\") |> \n    group_by(station,year,month) |> \n      summarize(precip=sum(precip,na.omit=T)) |> \n      arrange(station,year,month) |> \n    ungroup() |> \n    mutate(date_time=ymd(paste(year,month,15))) |> \n    select(-year,-month) |> \n    pivot_wider(id_cols=\"date_time\",names_from=station,values_from=precip)-> \n    focal_precip_monthly\n  \n  focal_precip_monthly_xts <- xts::xts(x=select(focal_precip_monthly,-date_time), order.by = focal_precip_monthly$date_time) \n\n\n```\n\n```{r generate_temp_dataset, echo = FALSE, warning = FALSE, message = FALSE}\n\n    #mean daily temp dataset\n\n  focal_weather%>%\n  group_by(station_name,year,month,day)%>%\n  summarise(daily_temp_C = mean(na.omit(temp_c)))%>%\n  ungroup() %>%\nmutate(date_time = paste(year,month,day,sep = \"-\"))%>%\n  mutate(date_time = strptime(date_time,format = \"%Y-%m-%d\"))%>%\n  dplyr::filter(!is.na(date_time))%>%\n  dplyr::select(date_time,station_name, daily_temp_C) %>%\n  pivot_wider(values_from = daily_temp_C,\n              names_from = station_name,\n              values_fn = mean) %>%\n   mutate(doy =  lubridate::yday(date_time) ) %>%\n   left_join(x=.,\n             y  = group_by(., doy) %>%\n               summarize(mean = mean(c_across(!contains(c(\"doy\",\"date_time\"))),\n                                         na.rm=TRUE))\n             ) %>%\n  dplyr::select(-doy)%>%\n    xts::xts(order.by = .$date_time) -> focal_mean_daily_temp\n\n```\n\n```{r generate_sf_of_stations, echo = FALSE, warning = FALSE, message = FALSE}\n  \n  \n#Generate sf of station points\n  \n  # focal_stations_sf <-\n  # stations_sf %>%\n  #   filter(usaf %in%gsub(pattern = \".gz.parquet\",\n  #                        replacement = \"\",x = closest_stations)) %>%\n  #   st_transform(st_crs(fires_wgs_truncated))\n\n  focal_stations_sf <-\n  stations %>%\n    filter(STNID %in% gsub(pattern = \".gz.parquet\",\n                          replacement = \"\",\n                          x = closest_stations)) %>%\n    st_transform(st_crs(fires_wgs_truncated))\n    \n```\n\n```{r crop invasives, fig.width = 10, fig.height = 7, echo = FALSE, warning = FALSE, message = FALSE}\n\ninat_data %>%\n  filter(invasive==T & \n           as_date(observed_on)>(today()-as.difftime(900, units = \"days\"))) |> \n      st_crop(y = focal_wgs %>%\n                st_buffer(dist = 1000)) -> focal_invasives\n\n\ninat_data %>%\n  filter(invasive==T & \n           as_date(observed_on)<=(today()-as.difftime(900, units = \"days\"))) |> \n      st_crop(y = focal_wgs %>%\n                st_buffer(dist = 1000)) -> focal_old_invasives\n\n\n# if there are no data, make a dataframe with NAs so that leaflet doesn't fail (will still throw error)\n\nif(nrow(focal_invasives) == 0){\n  \n\n  invasive_labels <- NULL\n  \n}else{\n  \n  invasive_labels <- focal_invasives$scientific_name\n  \n}\n\n```\n\n\n# `r focal_park_name`\n\n\n## NDVI and Time Since Fire\n\n\n```{r ndvi_and_burns, fig.width = 10, fig.height = 7, echo = FALSE, warning = FALSE, message = FALSE}\n\n  leaflet(data = focal_wgs) %>%\n  addProviderTiles(\"Esri.NatGeoWorldMap\", group = \"NatGeo\") %>%\n    #addProviderTiles(\"NASAGIBS.ModisTerraTrueColorCR\", group = \"True Colors\") %>%\n    addProviderTiles(providers$Esri.WorldImagery, group = \"World Imagery\") %>%\n  addPolygons(color = \"black\",\n              stroke = TRUE,\n              fill = FALSE,\n              group = \"Park\") %>%\n  addRasterImage(x = raster::raster(most_recent_ndvi.tif),\n                 group = \"NDVI\",\n                 colors = ndvi_pal) %>%\n    # addRasterImage(x = raster::raster(delta_ndvi.tif),\n    #              group = \"delta NDVI<br/>(long-term)\",\n    #              colors = delta_ndvi_pal) %>%\n  # addRasterImage(x = raster::raster(quarterly_delta_ndvi.tif),\n  #              group = \"delta NDVI<br/>(quarterly)\",\n  #              colors = delta_ndvi_pal) %>%\n  addRasterImage(x = raster::raster(monthly_delta_ndvi.tif),\n                 group = \"delta NDVI<br/>(monthly)\",\n                 colors = delta_ndvi_pal) %>%\n  hideGroup(\"delta NDVI<br/>(quarterly)\") %>%\n  \n  # Add recent invasive species\n   \n  addCircleMarkers(data = focal_invasives,\n             label = invasive_labels,\n             group = \"Invasives (new)\",\n             stroke = FALSE,\n             fillOpacity = 1,\n             fillColor = \"darkgrey\",\n             radius = 5) %>%\n  \n  addPolygons(data = fires_wgs_truncated,\n              color = \"red\",\n              fill = TRUE,\n              fillOpacity = 0,\n              stroke = TRUE,\n              label = paste(fires_wgs$Years, \"years since burn\"),\n              weight = 1,\n              group = \"Fire Outlines\") %>%\n    addPolygons(data = fires_wgs_truncated,\n              color = ~antipal(Years),\n              fillOpacity = .75,\n              stroke = FALSE,\n              label = fires_wgs$Years,\n              group = \"Fires\") %>%\n    addMarkers(data = focal_stations_sf,\n               label = focal_stations_sf$station_name,\n               group = \"Stations\") %>%\n    \n    # turn off some layers by default\n  \n    hideGroup(\"Stations\") %>%\n    hideGroup(\"Invasives (new)\") %>%\n    hideGroup(\"NDVI\") %>%\n    hideGroup(\"delta NDVI<br/>(long-term)\") %>%\n  \n    # add legends\n  \n    leaflet::addLegend(position = \"topright\",\n                     pal = delta_ndvi_pal,          \n                     values = ~values(monthly_delta_ndvi.tif),\n                     #values = ~c(-1,1),\n                     opacity = 1,\n                     title = \"delta<br/>NDVI\") %>%\n  \n    leaflet::addLegend(position = \"topright\",\n            pal = ndvi_pal,          \n            values = ~values(raster::raster(most_recent_ndvi.tif)),\n            #values = ~c(-1,1),\n            opacity = 1,\n            title = \"NDVI\") %>%\n\n    addLegend_decreasing(position = \"bottomright\",\n            pal = pal,\n            values = ~fires_wgs_truncated$Years,\n    title = \"Years<br/>Since<br/>Fire\",\n    opacity = 1) %>%\n  \n    addLayersControl(\n    baseGroups = c(\"NatGeo\",\"World Imagery\"),\n    overlayGroups = c(\"Park\",\n                      \"Stations\",\n                      \"delta NDVI<br/>(monthly)\",\n                      \"delta NDVI<br/>(long-term)\",\n                      #\"delta NDVI<br/>(quarterly)\",\n                      \"NDVI\",\n                      \"Fire Outlines\",\n                      \"Fires\",\n                      \"Invasives (new)\"\n                      ),\n    options = layersControlOptions(collapsed = FALSE),position = \"topleft\") %>%\n  fitBounds(bbox[1], bbox[2], bbox[3], bbox[4])\n\n```\n\nFigure 1. Leaflet map showing delta NDVI, NDVI, number of years since the most recent fire, and recent invasive species records. NA values in the delta NDVI and NDVI layers indicate missing data (e.g. due to clouds, water, etc.). Delta NDVI is the difference between observed NDVI and expected NDVI (i.e., the long-term mean). Monthly delta NDVI is calculated relative to the mean NDVI of the current month across the MODIS record while long-term delta NDVI is calculated relative the mean NDVI across the entire MODIS record. NA values in the delta NDVI layer indicate missing data (e.g. due to clouds, water, etc.). NDVI data are from `r most_recent_ndvi_date`. NA values in the fire layer indicate that no fires have been recorded for that area. Note that the color scale for fires has been truncated, and any sites with more than 20 years since fire appear as 20. The number of years since fire can be seen by hovering your cursor over the polygon of interest. Vegetation age polygons for the park are available at: `#r park_fires_file`. A raster layer of vegetation age (years since fire) is available at https://github.com/AdamWilsonLab/emma_report/releases/download/current/years_since_fire.tif .The mean current NDVI layer is available at https://github.com/AdamWilsonLab/emma_envdata/releases/download/current/mean_ndvi.tif .\n\n## Area burned and vegetation ages\n\n```{r vegetation ages over time, fig.width = 10, fig.height = 7, echo = FALSE, warning = FALSE, message = FALSE}\n\n# Subset park_fire_history to only the focal park\n\n  # use the ndvi raster as a template to get cells in park\n\n    most_recent_ndvi.tif %>%\n      terra::extract(y = vect(focal_park),\n                     cells = TRUE,\n                     touches = TRUE) %>%\n    dplyr::select(cell) -> focal_cells\n\n  # subset fire data\n\n  focal_fires <-\n    park_fire_history %>%\n    filter(cellID %in% focal_cells$cell)\n  \n  \n  # if empty, fill in NAs\n  \n    if(nrow(focal_fires) == 0){\n      \n      focal_fires <- expand.grid(cellID = focal_cells$cell,\n                                 date = unique(park_fire_history$date),\n                                 days_since_fire = NA)  \n      \n      \n    }\n  \n    \n  # dealing with missing cells/ages\n  \n    focal_fires %>%\n      pivot_wider(names_from = date,\n                  values_from = days_since_fire) %>%\n      full_join(y = focal_cells,\n                by = c(\"cellID\"=\"cell\")) %>%\n      pivot_longer(cols = !1, # make sure this ncol is pointing to the correct thing\n                   names_to = \"date\",\n                   values_to = \"days_since_fire\") %>%\n                mutate(cellID = as.factor(cellID),\n                       years_since_fire = days_since_fire/365.25,\n                       date =as.numeric(date))%>%\n                    mutate(date = as_date(date),\n                       year = year(date))%>%\n      mutate(years_since_fire = case_when(is.na(years_since_fire) ~ 20,\n                                          years_since_fire >= 0 ~ years_since_fire,\n                                          years_since_fire < 0 ~ 20)) -> ff2\n  \n        \nff2 %>%\n  mutate(gte20 = years_since_fire >= 20) %>%\n  group_by(year,gte20) %>%\n  count()%>%\n  ungroup()%>%\n  group_by(year)%>%\n  mutate(total=sum(n))%>%\n  mutate(fraction = n/total)%>%\n  filter(gte20)-> unburned_summary        \n        \nff2 %>%\n  filter(years_since_fire<20)%>%\n  mutate(year=as.factor(year))%>%\nggplot(mapping = aes(x=years_since_fire,\n                     y=year,\n                     fill=after_stat(x)))+\n  geom_density_ridges_gradient()+\n  labs(fill = \"Age\")+\n  xlab(\"Vegetation Age Distribution\")+\n  ylab(\"Year\")+\n  theme_bw()+\n  theme(legend.position = \"none\")+\n  geom_text(data = unburned_summary,\n            aes(label = paste(round(fraction,2)*100,\"%\"),\n                y=as.factor(year),\n                x = max(ff2$years_since_fire)), \n            position = position_stack(),\n            inherit.aes = F)+\n  scale_y_discrete(expand = c(.05, 0.2))+\n  coord_flip() -> p1\n        \n\nfocal_fires |> \n  mutate(year=year(as_date(date))) |> \n  group_by(year) |> \n  summarize(area_burned=sum(ifelse(days_since_fire<45,1,0))) |>\n  ggplot(aes(x=year,y=area_burned))+\n  geom_line()+\n  ylab(\"Area Burned\")+\n  xlab(\"\")+\n   scale_x_continuous(\n      breaks = seq(min(year(as_date(focal_fires$date))), max(year(as_date(focal_fires$date))), by = 1)) ->  # One tick per year\n  p_burnedarea\n\nplot_grid(p_burnedarea, p1, ncol=1, align = \"v\", labels = \"AUTO\",rel_heights = c(0.3,0.7),label_size = 0) \n     \n```\n\nFigure 2. Top: Total area burned each year in the park.  Bottom: Ridgeplot histogram showing vegetation age distributions within the park over time. Percentages shown represent amount of vegetation that is 20 years old or older. Note that areas where fires are not known to have occurred have been assigned a vegetation age of 20 years.\n\n\n```{r vegetation ages, fig.width = 10, fig.height = 7, echo = FALSE, warning = FALSE, message = FALSE, eval=F}\n  \n## Current Vegetation Age Distribution\n\n  # set NA values to 21 (we'll reset anything higher than 20 to 20+ for visualization)\n  # mask years since fire raster to the park\n\n  ysf_masked <- years_since_fire.tif\n  ysf_masked[is.na(ysf_masked)] <- 21\n  ysf_masked %>%\n  mask(focal_park) -> ysf_masked\n\n  # library(tidyterra)\n  # ggplot()+\n  #   geom_sf(data = focal_park)+\n  #   geom_spatraster(data = ysf_masked %>%\n  #                     crop(ext(focal_park)),\n  #                   mapping = aes(fill = lyr.1))+\n  #   coord_sf(crs=crs(ysf_masked))+\n  #   scale_fill_terrain_c()\n  \n  data.frame(Vegetation_Age = values(ysf_masked) %>%\n               as.vector()) %>%\n    filter(!is.na(Vegetation_Age)) %>%\n    mutate( Vegetation_Age = case_when(Vegetation_Age > 20 ~ 20,\n                                       .default = Vegetation_Age)) %>%\n    mutate(Vegetation_Age = round(x = Vegetation_Age, digits = 2))-> test\n  \n  \n    km2_per_pixel <- res(ysf_masked)[1]*res(ysf_masked)[2]*1e-6\n    \n    \n    \n    test %>%\n    ggplot(mapping = aes(x = Vegetation_Age))+\n    geom_histogram()+\n    xlab(\"Vegetation Age (years)\")+\n    scale_x_continuous(breaks = c(0,5,10,15,20),\n    labels = c(0,5,10,15,\"20(+)\"),\n    limits = c(0,21),\n    expand = c(0,0))+\n      #convert to km2\n    scale_y_continuous(expand = c(0,0),\n                       labels = function(x){\n                         round(x * res(ysf_masked)[1] * res(ysf_masked)[2] * 1e-6,\n                                                  digits = 0)})+\n      ylab(expression(paste(\"Area \", (km^2) )))+\n    theme_bw()\n    \n\n    \nFigure 3. Histogram of vegetation ages. For the purposes of this plot, any vegetation known to either be 20 years old or older, or for which we have no recorded records of fire, has been assigned an age of 20(+) years. The area shown was calculated by mutliplying counts of MODIS pixels at each age with the area of each pixel in square kilometers.\n\n\n\n```\n\n\n## Weather Data\n\n```{r weatherdyplot, echo=FALSE, message=FALSE, warning=FALSE}\n\n  # see: https://rstudio.github.io/dygraphs/\n\n# Define a shared group name\nshared_group <- \"weather_group\"\n\nfocal_precip_df <- as.data.frame(focal_precip) |> \n   mutate(across(where(is.numeric) & !any_of(\"date_time\"), function(x) log1p(ifelse(x<0.001,0,x))))\n\nfocal_precip_trans <- ts(focal_precip_df,\n                         start = start(focal_precip),\n                         frequency = frequency(focal_precip))\n\ndygraph(focal_precip_trans,\n        main = \"Precipitation (log1p-transformed)\",\n        xlab = \"Date\",\n        ylab = \"log1p(Precip mm)\",\n       group = shared_group) %>%\n      dyAxis(\"y\",\n         label = \"Precip. (mm)\",\n         axisLabelFormatter = JS(\n           \"function(value, granularity, opts, dygraph) {\n              return Math.round(Math.exp(value) - 1);\n            }\"\n         ),\n         valueFormatter = JS(\n    \"function(num, opts, seriesName, g, row, col) {\n       return (Math.exp(num) - 1).toFixed(2);\n     }\"\n  ))  |> \n  dySeries() %>%\n  dyRangeSelector() ->\n  precip_graph\n\n\n      dygraph(data = focal_mean_daily_temp[,colnames(focal_mean_daily_temp)[which(colnames(focal_mean_daily_temp)!=\"date_time\")]],\n          main = \"Temperature\",\n          xlab = \"Date\",\n          ylab = \"Temp. (C)\",\n          group = shared_group) %>%\n    dySeries() %>%\n    dyRangeSelector(dateWindow = c( Sys.Date() - time_window_days, Sys.Date())) -> mean_temp_graph\n\n```\n\n```{r plot_precip, echo=F, eval = TRUE, message = F, fig.width = 10, fig.height = 6}\n#| fig-cap: \n#|   - \"Figure 4. Climate Data from GSOD.  Mean data is a long-term average for each day of the year across these weather stations.\"\n  #This code chunk plots the targets visualization.\n  # I do this in two steps to avoid errors that otherwise can occur\n\n  precip_graph\n\n```\n\n```{r plot_temp, echo=F, eval = TRUE, message = F, fig.width = 10, fig.height = 6}\n#| fig-cap: \n#|   - \"Figure 5. Climate Data from GSOD.  Mean data is a long-term average for each day of the year across these weather stations.\"\n\n\n  #This code chunk plots the targets visualization.\n  # I do this in two steps to avoid errors that otherwise can occur\n\n  #temp_graph\n  mean_temp_graph\n\n```\n\n## Drought Indices\n\n```{r NDWI_plot, fig.width = 10, fig.height = 7, echo = FALSE, warning = FALSE, message = FALSE, eval=FALSE, include=FALSE}\n  leaflet(data = focal_wgs) %>%\n  addProviderTiles(\"Esri.NatGeoWorldMap\", group = \"NatGeo\") %>%\n    #addProviderTiles(\"NASAGIBS.ModisTerraTrueColorCR\", group = \"True Colors\") %>%\n    addProviderTiles(providers$Esri.WorldImagery, group = \"World Imagery\") %>%\n  addPolygons(color = \"black\",\n              stroke = TRUE,\n              fill = FALSE,\n              group = \"Park\") %>%\n  addRasterImage(x = ndwi_rast,\n                 group = \"NDWI\",\n                 #colors = ndwi_pal\n                 colors = ndwi_bin_pal,\n                 opacity = 0.8\n                 )%>% \n  addMouseCoordinates() %>%\n      addImageQuery(ndwi_rast, type=\"mousemove\", layerId = \"NDWI\") %>%\n  leaflet::addLegend(position = \"bottomright\",\n            #pal = ndwi_pal,\n            pal = ndwi_bin_pal,\n            values = ~values(ndwi_rast),\n            opacity = 1,\n            title = \"NDWI\") %>%\n    addLayersControl(\n    baseGroups = c(\"NatGeo\",\"World Imagery\"),\n    overlayGroups = c(\"NDWI\", \"Park\"),\n    options = layersControlOptions(collapsed = FALSE),position = \"topright\") %>%\n  fitBounds(bbox[1], bbox[2], bbox[3], bbox[4])\n\n# Below is the text that accompanies this figure  \n#   Figure 6. The Normalized Difference Water Index [(NDWI)](https://en.wikipedia.org/wiki/Normalized_difference_water_index) is a measure of the water content of leaves ranging between -1 (no water) and 1 (water). The NDWI data were last updated on `r most_recent_ndwi_date` (although they may be older than the update date).\n# \n# Interpreting NDWI:\n# \n#   * 1 - 0.2 = Water surface,\n#   * 0.2 – 0.0 = Flooding, humidity,\n#   * 0.0 – -0.3 = Moderate drought, non-aqueous surfaces,\n#   * -0.3 – -1 = Drought, non-aqueous surface\n\n  \n\n```\n\n### SPI\n\nThe Standardized Precipitation Index [(SPI)](https://gmao.gsfc.nasa.gov/research/subseasonal/atlas/SPI-html/SPI-description.html#:~:text=The%20SPI%20is%20used%20for,from%20subseasonal%20to%20interannual%20scales.) is a drought index ranging from -3 (very dry) to +3 (very wet).\n\n```{r calc_spi_1, eval = TRUE, fig.width = 10, fig.height = 7, echo = FALSE, warning = FALSE, message = FALSE}\n\n  #Make a dataset with only mostly complete data\n\n  stations_to_keep <-\n    bind_cols(date_time=time(focal_precip_monthly_xts),focal_precip_monthly_xts)%>%\n    pivot_longer(cols = !date_time,\n                 names_to = \"station_name\",\n                 values_to = \"monthly_precip_mm\") %>%\n    group_by(station_name) %>% \n    summarize(fraction_na = sum(is.na(monthly_precip_mm))/length(monthly_precip_mm)) %>% \n    filter(fraction_na < 0.05) %>%\n    dplyr::select(station_name)\n\n  \n  focal_precip_monthly_xts %>%\n     as.data.frame() %>%\n    .[stations_to_keep$station_name] %>%\n     mutate_if(is.character, as.numeric) -> focal_spi_data\n\n  \n  # Only use the mean estimates if those are the only complete ones\n\n    #focal_spi_data %>%\n    #dplyr::select(!mean) -> focal_spi_data\n      \n      \n    if(ncol(focal_spi_data)>0){\n  \n      spi_window=6 # number of months of moving window\n\nspi <- spi(data = ts(focal_spi_data,\n                           frequency = 12,\n                           start = c(rownames(focal_spi_data)[1]%>%\n                                       substr(start = 0,stop = 4),\n                                     rownames(focal_spi_data)[1]%>%\n                                       substr(start = 6,stop = 7))),\n                 scale =  spi_window,\n                 verbose = FALSE,\n                 na.rm = TRUE)\n\nspi2 <- as_tibble(spi$fitted) %>%\n  mutate(date = as.Date(as.yearmon(time(spi$fitted)))) %>%\n  relocate(date) %>%\n  pivot_longer(-date, names_to = \"station\", values_to = \"spei\") #|> \n # mutate(       # Create a new column to separate positive and negative SPEI\n#    spei_pos = ifelse(spei > 0, spei, 0),\n#    spei_neg = ifelse(spei < 0, spei, 0)\n#  )\n\n\n\n\n    }\n      \n```\n\n```{r spiplot, eval = TRUE, fig.width = 10, fig.height = 10, echo = FALSE, warning = FALSE, message = FALSE}\n\n  if(ncol(focal_spi_data)>0){\n\n# # Plot with separate fill colors for positive and negative values\n# ggplot(spi2, aes(x = date)) +\n#   geom_hline(yintercept = 0, color = grey(0.6)) +\n# #  geom_line(aes(y = spei), col=\"transparent\") + #for plotly to return simple value?\n#   geom_area(aes(y = spei_pos), fill = \"darkblue\") +\n#   geom_area(aes(y = spei_neg), fill = \"darkred\") +\n#   geom_smooth(aes(y = spei), span = 0.2, se = TRUE,col=\"black\") +\n#   ggtitle(\"6 Month Standardized Precipitation Index (SPI)\") +\n#   ylab(\"Standardized Precipitation Index (SPI)\")+\n#   xlab(\"Date\") +\n#   facet_wrap(~station,ncol=1)+\n#       coord_equal(ratio = 100)+\n#   theme_minimal()  -> p_spi\n#   \n#     #ggplotly(p_spi,layerData = 2)\n#      p_spi\n#   }\n\n\n# Plot with separate fill colors for positive and negative values\nggplot(spi2, aes(x = date)) +\n  geom_hline(yintercept = 0, color = grey(0.6)) +\n  geom_line(aes(y = spei,col=station)) + \n  geom_smooth(aes(y = spei), span = 0.3, se = TRUE,col=\"black\") +\n  ggtitle(paste0(\"Standardized Precipitation Index (SPI with \",spi_window,\" Month window)\")) +\n  scale_color_viridis_d()+\n  ylab(\"Standardized Precipitation Index (SPI)\")+\n  xlab(\"Date\") +\n  theme_minimal()  -> p_spi\n\n    p_spi\n    \n    spi2 |> \n      pivot_wider(names_from = station,values_from = spei) |> \n      dygraph(\n          main = \"Standardized Precipitation Index (SPI with 6 Month window)\",\n          xlab = \"Date\",\n          ylab = \"SPI\",\n          group = shared_group) %>%\n    dySeries() %>%\n    dyRangeSelector(dateWindow = c( Sys.Date() - time_window_days, Sys.Date())) -> spi_graph\n    \n    \n  spi_graph\n    \n}\n```\n\n# Report Metadata\n\nThis table summarizes the date this report was generated and the most recent observation for each data type.\n\n```{r, echo=F, results='asis'}\n# build table of dates when products were last updated\n\ndates <- bind_rows(\n  data.frame(Description = \"Website\", Date = format(now(), \"%Y-%b-%d\")),\n  data.frame(Description = \"NDVI\", Date = format(most_recent_ndvi_date, \"%Y-%b-%d\")),\n  data.frame(Description = \"Weather\", Date = format(max(focal_weather$date_time), \"%Y-%b-%d\"))\n) |> \n  select(Description, \"Date last updated\"=Date)\n\nknitr::kable(dates)\n \n```\n","srcMarkdownNoYaml":"\n\n\n```{r, echo=F, message = F, results = \"hide\"}\nlibrary(targets)\nlibrary(tidyverse)\nlibrary(doParallel)\n#library(raster)\nlibrary(lubridate)\nlibrary(sf)\nlibrary(xts)\nlibrary(plotly)\nlibrary(leaflet)\nlibrary(dygraphs)\nlibrary(terra)\nlibrary(cowplot)\nlibrary(ggridges)  \nlibrary(dygraphs)\nlibrary(mapview)\nlibrary(leafem)\nlibrary(SPEI)\n\n```\n\n```{r load_targets, echo=F, message=FALSE}\ntar_load(protected_areas)\n#tar_load(most_recent_fire.tif)\ntar_load(park_fire_history)\ntar_load(temp_directory)\ntar_load(years_since_fire.tif)\ntar_load(fires_wgs)\ntar_load(most_recent_ndvi.tif)\ntar_load(most_recent_ndvi_date)\ntar_load(monthly_mean_ndvi.tif)\ntar_load(monthly_delta_ndvi.tif)\ntar_load(weather_data)\n#tar_load(mean_ndvi.tif)\n#tar_load(delta_ndvi.tif)\n#tar_load(most_recent_quarter_ndvi_file)\n#tar_load(quarterly_delta_ndvi.tif)\ntar_load(stations)\ntar_load(inat_data)\n\n\ntime_window_days=365\n\n```\n\n\n```{r data_prep, echo = FALSE, warning = FALSE, message = FALSE,include=FALSE}\n\n# get focal park from yaml\nfocal_park_name <- params$focal_park_name\n\n# set for testing\nif(F) focal_park_name <- \"Table Mountain National Park\"\n\n\nfocal_park=protected_areas |> \n  st_as_sf() |> \n  filter(name==focal_park_name)\n\n\n# CREATE wgs84 version of the park polygon\n\n    focal_park |> \n    st_transform(crs = st_crs(4326)) |> \n    st_make_valid() -> \n    focal_wgs\n\n# Create buffered fire age polygon\n\n    # make park-specific fire ages file\n      \n\n      fires_wgs %>%\n      st_crop(y = focal_wgs %>%\n                st_buffer(dist = 10000)) ->\n        focal_fires\n      \n      park_no_spaces <- gsub(pattern = \" \",replacement = \"_\",x = focal_park_name)\n\n      # focal_fires %>%\n      #   st_write(dsn = file.path(temp_directory, paste(park_no_spaces,\"fires.gpkg\",sep = \"_\")),\n      #            append=FALSE,\n      #            quiet = TRUE\n      #            )\n      # \n      # robust_pb_upload(file = file.path(temp_directory, paste(park_no_spaces,\"fires.gpkg\",sep = \"_\")),\n      #                  repo = \"AdamWilsonLab/emma_report\",\n      #                  tag = park_data_tag)\n      # \n      # file.remove(file.path(temp_directory, paste(park_no_spaces,\"fires.gpkg\",sep = \"_\")))\n      \n\n# Park-specific file link\n#    park_fires_file  <- paste(\"https://github.com/AdamWilsonLab/emma_report/releases/download/park_data/\",\n#                              paste(park_no_spaces,\"fires.gpkg\",sep= \"_\"),sep = \"\")\n\n# Create a truncated version of the fire maps (ranging from 1-20)\n\n  fires_wgs %>%\n    mutate(Years = case_when(Years > 20 ~ 20,\n                             Years <=20 ~ Years)) -> fires_wgs_truncated\n  \n\n\n#Note that the \"addLegend_decreasing\" isn't quite right, but might be close enough if you feel strongly about the ordering\n\naddLegend_decreasing <- function (map, position = c(\"topright\", \"bottomright\", \"bottomleft\", \n\t\t\t    \"topleft\"), pal, values, na.label = \"NA\", bins = 7, colors, \n\t\t  opacity = 0.5, labels = NULL, labFormat = labelFormat(), \n\t\t  title = NULL, className = \"info legend\", layerId = NULL, \n\t\t  group = NULL, data = getMapData(map), decreasing = FALSE) {\n\tposition <- match.arg(position)\n\ttype <- \"unknown\"\n\tna.color <- NULL\n\textra <- NULL\n\tif (!missing(pal)) {\n\t\tif (!missing(colors)) \n\t\t\tstop(\"You must provide either 'pal' or 'colors' (not both)\")\n\t\tif (missing(title) && inherits(values, \"formula\")) \n\t\t\ttitle <- deparse(values[[2]])\n\t\tvalues <- evalFormula(values, data)\n\t\ttype <- attr(pal, \"colorType\", exact = TRUE)\n\t\targs <- attr(pal, \"colorArgs\", exact = TRUE)\n\t\tna.color <- args$na.color\n\t\tif (!is.null(na.color) && col2rgb(na.color, alpha = TRUE)[[4]] == \n\t\t    0) {\n\t\t\tna.color <- NULL\n\t\t}\n\t\tif (type != \"numeric\" && !missing(bins)) \n\t\t\twarning(\"'bins' is ignored because the palette type is not numeric\")\n\t\tif (type == \"numeric\") {\n\t\t\tcuts <- if (length(bins) == 1) \n\t\t\t\tpretty(values, bins)\n\t\t\telse bins\t\n\t\t\t\n\t\t\tif (length(bins) > 2) \n\t\t\t\tif (!all(abs(diff(bins, differences = 2)) <= \n\t\t\t\t         sqrt(.Machine$double.eps))) \n\t\t\t\t\tstop(\"The vector of breaks 'bins' must be equally spaced\")\n\t\t\tn <- length(cuts)\n\t\t\tr <- range(values, na.rm = TRUE)\n\t\t\tcuts <- cuts[cuts >= r[1] & cuts <= r[2]]\n\t\t\tn <- length(cuts)\n\t\t\tp <- (cuts - r[1])/(r[2] - r[1])\n\t\t\textra <- list(p_1 = p[1], p_n = p[n])\n\t\t\tp <- c(\"\", paste0(100 * p, \"%\"), \"\")\n\t\t\tif (decreasing == TRUE){\n\t\t\t\tcolors <- pal(rev(c(r[1], cuts, r[2])))\n\t\t\t\tlabels <- rev(labFormat(type = \"numeric\", cuts))\n\t\t\t}else{\n\t\t\t\tcolors <- pal(c(r[1], cuts, r[2]))\n\t\t\t\tlabels <- rev(labFormat(type = \"numeric\", cuts))\n\t\t\t}\n\t\t\tcolors <- paste(colors, p, sep = \" \", collapse = \", \")\n\t\t\t\n\t\t}\n\t\telse if (type == \"bin\") {\n\t\t\tcuts <- args$bins\n\t\t\tn <- length(cuts)\n\t\t\tmids <- (cuts[-1] + cuts[-n])/2\n\t\t\tif (decreasing == TRUE){\n\t\t\t\tcolors <- pal(rev(mids))\n\t\t\t\tlabels <- rev(labFormat(type = \"bin\", cuts))\n\t\t\t}else{\n\t\t\t\tcolors <- pal(mids)\n\t\t\t\tlabels <- labFormat(type = \"bin\", cuts)\n\t\t\t}\n\t\t\t\n\t\t}\n\t\telse if (type == \"quantile\") {\n\t\t\tp <- args$probs\n\t\t\tn <- length(p)\n\t\t\tcuts <- quantile(values, probs = p, na.rm = TRUE)\n\t\t\tmids <- quantile(values, probs = (p[-1] + p[-n])/2, \n\t\t\t\t na.rm = TRUE)\n\t\t\tif (decreasing == TRUE){\n\t\t\t\tcolors <- pal(rev(mids))\n\t\t\t\tlabels <- rev(labFormat(type = \"quantile\", cuts, p))\n\t\t\t}else{\n\t\t\t\tcolors <- pal(mids)\n\t\t\t\tlabels <- labFormat(type = \"quantile\", cuts, p)\n\t\t\t}\n\t\t}\n\t\telse if (type == \"factor\") {\n\t\t\tv <- sort(unique(na.omit(values)))\n\t\t\tcolors <- pal(v)\n\t\t\tlabels <- labFormat(type = \"factor\", v)\n\t\t\tif (decreasing == TRUE){\n\t\t\t\tcolors <- pal(rev(v))\n\t\t\t\tlabels <- rev(labFormat(type = \"factor\", v))\n\t\t\t}else{\n\t\t\t\tcolors <- pal(v)\n\t\t\t\tlabels <- labFormat(type = \"factor\", v)\n\t\t\t}\n\t\t}\n\t\telse stop(\"Palette function not supported\")\n\t\tif (!any(is.na(values))) \n\t\t\tna.color <- NULL\n\t}\n\telse {\n\t\tif (length(colors) != length(labels)) \n\t\t\tstop(\"'colors' and 'labels' must be of the same length\")\n\t}\n\tlegend <- list(colors = I(unname(colors)), labels = I(unname(labels)), \n\t               na_color = na.color, na_label = na.label, opacity = opacity, \n\t               position = position, type = type, title = title, extra = extra, \n\t               layerId = layerId, className = className, group = group)\n\tinvokeMethod(map, data, \"addLegend\", legend)\n}\n\n\n# Create continuous palettes\n\n  pal <- colorNumeric(palette = \"Reds\",\n                      domain = fires_wgs_truncated$Years,\n                      reverse = TRUE)\n\n  antipal <- colorNumeric(palette = \"Reds\",\n                          domain = fires_wgs_truncated$Years,reverse = FALSE)\n  \n  \n  ndvi_pal <- colorNumeric(palette = c( \"#FFFFCC\", \"#41B6C4\",\"#0C2C84\"),\n                           #domain =  values(most_recent_ndvi.tif),\n                           domain =  c(-1,0,1),\n                           na.color = \"transparent\")\n  \n  #max_delta_ndvi <- max(abs(values(delta_ndvi.tif)),na.rm = TRUE)\n  max_delta_ndvi <- max(abs(values(monthly_delta_ndvi.tif)),na.rm = TRUE)\n  \n  delta_ndvi_pal <- colorNumeric(palette = c( \"brown\", \"white\",\"forestgreen\"),\n                                 #domain =  values(most_recent_ndvi.tif),\n                                 domain =  c(max_delta_ndvi*-1,max_delta_ndvi),\n                                 na.color = \"transparent\")\n\n  ndwi_pal <- colorNumeric(palette = c( \"#FFFFCC\", \"#41B6C4\",\"#0C2C84\"),\n                           #domain =  values(terra::rast(ndwi_rast)),\n                           domain = c(-1,1),\n                           na.color = \"transparent\")\n  \n  ndwi_bin_pal <- colorBin(palette = c( \"#FFFFCC\", \"#41B6C4\",\"#0C2C84\"),\n                           #domain =  values(terra::rast(ndwi_rast)),\n                           domain = c(-1,1),\n                           bins = c(-1,-.3,0.0,0.2,1),\n                           na.color = \"transparent\",\n                           alpha = TRUE)\n\n\n# Create bounding box for plotting  \n  \nbbox <- st_bbox(focal_wgs) %>%\n  as.vector()\n\n```\n\n```{r identify_closest_stations, echo = FALSE, warning = FALSE, message = FALSE}\n\n# Process the station and weather data\nn_stations=3 # number of stations to show\n  # Get data for closest weather stations\n  \n    cent <- suppressWarnings( focal_park %>%\n                                st_union()%>%\n                                st_centroid())\n    \n    closest_stations <- \n      data.frame(station = stations$STNID,\n                 name = stations$NAME,\n               distance = as.numeric(st_distance(cent,stations)))\n    \n    closest_stations <- closest_stations[order(closest_stations$distance),]\n    \n    closest_stations <- closest_stations$station[1:n_stations]\n    \n    # closest_stations %>%\n    #       gsub(pattern = \"/\",replacement = \"\",fixed = TRUE)%>% #what kind of sadist puts a slash in a name?\n    #       gsub(pattern = \" \",replacement = \"_\") %>%\n    #       gsub(pattern = \")\",replacement = \"_\",fixed = TRUE) %>%\n    #       gsub(pattern = \"(\",replacement = \"_\",fixed = TRUE) %>%\n    #       paste(.,\".gz.parquet\",sep = \"\")-> closest_stations\n    # \n\n    # robust_pb_download(file = closest_stations,\n    #             dest = temp_directory,\n    #             repo = \"AdamWilsonLab/emma_report\",\n    #             tag = \"GSOD\",\n    #             max_attempts = max_attempts,\n    #             sleep_time = sleep_time,\n    #             show_progress=FALSE) -> to_rm\n    # \n    # if(exists(\"to_rm\")){rm(to_rm)}\n    \n  #Hack in case some of the files aren't downloaded correctly.  \n    # closest_stations  <- intersect(closest_stations,\n    #                                list.files(temp_directory))\n\n    focal_weather=weather_data |> \n      filter(STNID%in%closest_stations)\n\n  if(nrow(focal_weather) < 1){stop(\"No weather data loaded\")}\n  \n```\n\n```{r reformat_to_match_noaa, echo = FALSE, warning = FALSE, message = FALSE}\n\n  #fix station names in focal weather (missing in many case)\n  \n    # stations %>%\n    # dplyr::select(usaf,wban,station_name)%>%\n    # inner_join(y = focal_weather,\n    #            by = c(\"usaf\"=\"usaf_station\",\"wban\"=\"wban_station\"),\n    #            multiple = \"all\")%>%\n    # dplyr::rename(station_name = station_name.x)-> focal_weather\n\n  #with dygraphs, first element should be x axis, or else do it as an xts\n  \n  # probably easiest to do xts, since its a time series anyway\n  \n  # focal_weather %>%\n  #   as.data.frame() %>% #for some reason, this code throws an error without this line.  no idea why.\n  #   mutate(year = substr(x = date,1,4),\n  #          month = substr(x = date,5,6),\n  #          day = substr(x=date,7,8),\n  #          hour= substr(x=time,1,2),\n  #          minute = substr(x=time,3,4)) %>%\n  #   mutate(date_time = paste(year,month,day,hour,minute,sep = \"-\"))%>%\n  #   mutate(date_time = strptime(date_time,format = \"%Y-%m-%d-%H-%M\"))%>%\n  #   dplyr::filter(!is.na(date_time)) -> focal_weather\n  \n  \n  #reformatting the GSOD to match NOAA format\n\n  focal_weather %>%\n    as.data.frame() %>%\n    dplyr::mutate(year = YEAR,\n                  month = MONTH,\n                  day = DAY,\n                  station_name = NAME,\n                  mean_precip_mm = PRCP,\n                  temp_c = TEMP) %>%\n    dplyr::mutate(date_time = paste(year,month,day,sep = \"-\")) %>%\n    dplyr::mutate(date_time = strptime(date_time,format = \"%Y-%m-%d\")) %>%\n    dplyr::filter(!is.na(date_time)) -> focal_weather\n\n```\n\n```{r filter_old_weather_data, echo = FALSE, warning = FALSE, message = FALSE}\n  \n  #Filter out oldest data\n  min_date = \"1970-01-01\"\n  focal_weather <- \n    focal_weather %>%\n    dplyr::filter(date_time > as_datetime(min_date,tz =tz(focal_weather$date_time)))\n\n```\n\n```{r generate_precip_dataset, echo = FALSE, warning = FALSE, message = FALSE}\n  \n  #Generate precip dataset\n  \n# focal_weather %>%\n#   group_by(station_name,year,month)%>%\n#   summarise(monthly_precip_mm = sum(na.omit(mean_precip_mm)))%>%\n#   ungroup() %>%\n#   mutate(date_time = paste(year,month,01,sep = \"-\"))%>%\n#   mutate(date_time = strptime(date_time,format = \"%Y-%m-%d\"))%>%\n#   mutate(date_time = lubridate::floor_date(date_time)-1)%>%\n#   dplyr::filter(!is.na(date_time))%>%\n#   dplyr::select(date_time,station_name, monthly_precip_mm) %>%\n#    filter(date_time>as_date(\"2000-01-01\")) |> \n#   pivot_wider(values_from = monthly_precip_mm,\n#               names_from = station_name,\n#               values_fn = mean) %>%\n#    mutate(doy =  lubridate::yday(date_time) ) %>%\n#    left_join(x=.,\n#              y  = group_by(., doy) %>%\n#                summarize(mean = mean(c_across(!contains(c(\"doy\",\"date_time\"))),\n#                                          na.rm=TRUE))\n#              ) %>%\n#  dplyr::select(-doy)%>%\n#   xts::xts(order.by = .$date_time) -> focal_precip\n  \n\nlibrary(zoo)\n# Set the rolling window size (must be odd for centering)\nwindow_size <- 61  # e.g., ±15 days = 31 total\n\n# Step 1: Prepare the daily data\nfocal_precip <- focal_weather %>%\n  filter(!is.na(mean_precip_mm)) %>%\n  select(station_name,date_time,mean_precip_mm) %>%\n  mutate(date_time = as_date(date_time)) %>%\n#  filter(date_time > as_date(\"2000-01-01\")) %>%\n  pivot_wider(\n    names_from = station_name,\n    values_from = mean_precip_mm,\n    values_fn = mean\n  ) %>%\n  mutate(doy = yday(date_time))\n\n# Step 2: Compute the daily climatology using all years\n# Average across stations by DOY\nfocal_precip_climatology <- focal_precip %>%\n  group_by(doy) %>%\n  summarise(clim_mean = mean(c_across(where(is.numeric)), na.rm = TRUE), .groups = \"drop\") %>%\n  arrange(doy)\n\n# Step 3: Apply rolling mean (wrap around to handle year start/end)\n# Pad the data for wrap-around\nextended <- bind_rows(\n  focal_precip_climatology %>% filter(doy > (366 - window_size)),\n  focal_precip_climatology,\n  focal_precip_climatology %>% filter(doy <= window_size)\n)\n\n# Compute the rolling mean twice to smooth it out\nextended$roll_mean <- zoo::rollmean(extended$clim_mean, k = window_size, fill = NA, align = \"center\") |> \n  zoo::rollmean(k = window_size, fill = NA, align = \"center\")\n\n# Step 4: Remove padding and match back to original DOY\nrolling_climatology <- extended %>%\n  slice((window_size + 1):(n() - window_size)) %>%\n  select(doy, mean = roll_mean)\n\n# Step 5: Join back to the daily weather data\nfocal_precip %>%\n  left_join(rolling_climatology, by = \"doy\") %>%\n  select(-doy) %>%\n   xts::xts(x=select(.,-date_time), order.by = .$date_time) -> focal_precip\n\n\n# calculate monthly totals\n  bind_cols(date_time=time(focal_precip),as.data.frame(focal_precip)) |> \n    mutate(year=year(as_date(date_time)),month=month(as_date(date_time))) |> \n    pivot_longer(-c(date_time,month,year),names_to=\"station\",values_to=\"precip\") |> \n    group_by(station,year,month) |> \n      summarize(precip=sum(precip,na.omit=T)) |> \n      arrange(station,year,month) |> \n    ungroup() |> \n    mutate(date_time=ymd(paste(year,month,15))) |> \n    select(-year,-month) |> \n    pivot_wider(id_cols=\"date_time\",names_from=station,values_from=precip)-> \n    focal_precip_monthly\n  \n  focal_precip_monthly_xts <- xts::xts(x=select(focal_precip_monthly,-date_time), order.by = focal_precip_monthly$date_time) \n\n\n```\n\n```{r generate_temp_dataset, echo = FALSE, warning = FALSE, message = FALSE}\n\n    #mean daily temp dataset\n\n  focal_weather%>%\n  group_by(station_name,year,month,day)%>%\n  summarise(daily_temp_C = mean(na.omit(temp_c)))%>%\n  ungroup() %>%\nmutate(date_time = paste(year,month,day,sep = \"-\"))%>%\n  mutate(date_time = strptime(date_time,format = \"%Y-%m-%d\"))%>%\n  dplyr::filter(!is.na(date_time))%>%\n  dplyr::select(date_time,station_name, daily_temp_C) %>%\n  pivot_wider(values_from = daily_temp_C,\n              names_from = station_name,\n              values_fn = mean) %>%\n   mutate(doy =  lubridate::yday(date_time) ) %>%\n   left_join(x=.,\n             y  = group_by(., doy) %>%\n               summarize(mean = mean(c_across(!contains(c(\"doy\",\"date_time\"))),\n                                         na.rm=TRUE))\n             ) %>%\n  dplyr::select(-doy)%>%\n    xts::xts(order.by = .$date_time) -> focal_mean_daily_temp\n\n```\n\n```{r generate_sf_of_stations, echo = FALSE, warning = FALSE, message = FALSE}\n  \n  \n#Generate sf of station points\n  \n  # focal_stations_sf <-\n  # stations_sf %>%\n  #   filter(usaf %in%gsub(pattern = \".gz.parquet\",\n  #                        replacement = \"\",x = closest_stations)) %>%\n  #   st_transform(st_crs(fires_wgs_truncated))\n\n  focal_stations_sf <-\n  stations %>%\n    filter(STNID %in% gsub(pattern = \".gz.parquet\",\n                          replacement = \"\",\n                          x = closest_stations)) %>%\n    st_transform(st_crs(fires_wgs_truncated))\n    \n```\n\n```{r crop invasives, fig.width = 10, fig.height = 7, echo = FALSE, warning = FALSE, message = FALSE}\n\ninat_data %>%\n  filter(invasive==T & \n           as_date(observed_on)>(today()-as.difftime(900, units = \"days\"))) |> \n      st_crop(y = focal_wgs %>%\n                st_buffer(dist = 1000)) -> focal_invasives\n\n\ninat_data %>%\n  filter(invasive==T & \n           as_date(observed_on)<=(today()-as.difftime(900, units = \"days\"))) |> \n      st_crop(y = focal_wgs %>%\n                st_buffer(dist = 1000)) -> focal_old_invasives\n\n\n# if there are no data, make a dataframe with NAs so that leaflet doesn't fail (will still throw error)\n\nif(nrow(focal_invasives) == 0){\n  \n\n  invasive_labels <- NULL\n  \n}else{\n  \n  invasive_labels <- focal_invasives$scientific_name\n  \n}\n\n```\n\n\n# `r focal_park_name`\n\n\n## NDVI and Time Since Fire\n\n\n```{r ndvi_and_burns, fig.width = 10, fig.height = 7, echo = FALSE, warning = FALSE, message = FALSE}\n\n  leaflet(data = focal_wgs) %>%\n  addProviderTiles(\"Esri.NatGeoWorldMap\", group = \"NatGeo\") %>%\n    #addProviderTiles(\"NASAGIBS.ModisTerraTrueColorCR\", group = \"True Colors\") %>%\n    addProviderTiles(providers$Esri.WorldImagery, group = \"World Imagery\") %>%\n  addPolygons(color = \"black\",\n              stroke = TRUE,\n              fill = FALSE,\n              group = \"Park\") %>%\n  addRasterImage(x = raster::raster(most_recent_ndvi.tif),\n                 group = \"NDVI\",\n                 colors = ndvi_pal) %>%\n    # addRasterImage(x = raster::raster(delta_ndvi.tif),\n    #              group = \"delta NDVI<br/>(long-term)\",\n    #              colors = delta_ndvi_pal) %>%\n  # addRasterImage(x = raster::raster(quarterly_delta_ndvi.tif),\n  #              group = \"delta NDVI<br/>(quarterly)\",\n  #              colors = delta_ndvi_pal) %>%\n  addRasterImage(x = raster::raster(monthly_delta_ndvi.tif),\n                 group = \"delta NDVI<br/>(monthly)\",\n                 colors = delta_ndvi_pal) %>%\n  hideGroup(\"delta NDVI<br/>(quarterly)\") %>%\n  \n  # Add recent invasive species\n   \n  addCircleMarkers(data = focal_invasives,\n             label = invasive_labels,\n             group = \"Invasives (new)\",\n             stroke = FALSE,\n             fillOpacity = 1,\n             fillColor = \"darkgrey\",\n             radius = 5) %>%\n  \n  addPolygons(data = fires_wgs_truncated,\n              color = \"red\",\n              fill = TRUE,\n              fillOpacity = 0,\n              stroke = TRUE,\n              label = paste(fires_wgs$Years, \"years since burn\"),\n              weight = 1,\n              group = \"Fire Outlines\") %>%\n    addPolygons(data = fires_wgs_truncated,\n              color = ~antipal(Years),\n              fillOpacity = .75,\n              stroke = FALSE,\n              label = fires_wgs$Years,\n              group = \"Fires\") %>%\n    addMarkers(data = focal_stations_sf,\n               label = focal_stations_sf$station_name,\n               group = \"Stations\") %>%\n    \n    # turn off some layers by default\n  \n    hideGroup(\"Stations\") %>%\n    hideGroup(\"Invasives (new)\") %>%\n    hideGroup(\"NDVI\") %>%\n    hideGroup(\"delta NDVI<br/>(long-term)\") %>%\n  \n    # add legends\n  \n    leaflet::addLegend(position = \"topright\",\n                     pal = delta_ndvi_pal,          \n                     values = ~values(monthly_delta_ndvi.tif),\n                     #values = ~c(-1,1),\n                     opacity = 1,\n                     title = \"delta<br/>NDVI\") %>%\n  \n    leaflet::addLegend(position = \"topright\",\n            pal = ndvi_pal,          \n            values = ~values(raster::raster(most_recent_ndvi.tif)),\n            #values = ~c(-1,1),\n            opacity = 1,\n            title = \"NDVI\") %>%\n\n    addLegend_decreasing(position = \"bottomright\",\n            pal = pal,\n            values = ~fires_wgs_truncated$Years,\n    title = \"Years<br/>Since<br/>Fire\",\n    opacity = 1) %>%\n  \n    addLayersControl(\n    baseGroups = c(\"NatGeo\",\"World Imagery\"),\n    overlayGroups = c(\"Park\",\n                      \"Stations\",\n                      \"delta NDVI<br/>(monthly)\",\n                      \"delta NDVI<br/>(long-term)\",\n                      #\"delta NDVI<br/>(quarterly)\",\n                      \"NDVI\",\n                      \"Fire Outlines\",\n                      \"Fires\",\n                      \"Invasives (new)\"\n                      ),\n    options = layersControlOptions(collapsed = FALSE),position = \"topleft\") %>%\n  fitBounds(bbox[1], bbox[2], bbox[3], bbox[4])\n\n```\n\nFigure 1. Leaflet map showing delta NDVI, NDVI, number of years since the most recent fire, and recent invasive species records. NA values in the delta NDVI and NDVI layers indicate missing data (e.g. due to clouds, water, etc.). Delta NDVI is the difference between observed NDVI and expected NDVI (i.e., the long-term mean). Monthly delta NDVI is calculated relative to the mean NDVI of the current month across the MODIS record while long-term delta NDVI is calculated relative the mean NDVI across the entire MODIS record. NA values in the delta NDVI layer indicate missing data (e.g. due to clouds, water, etc.). NDVI data are from `r most_recent_ndvi_date`. NA values in the fire layer indicate that no fires have been recorded for that area. Note that the color scale for fires has been truncated, and any sites with more than 20 years since fire appear as 20. The number of years since fire can be seen by hovering your cursor over the polygon of interest. Vegetation age polygons for the park are available at: `#r park_fires_file`. A raster layer of vegetation age (years since fire) is available at https://github.com/AdamWilsonLab/emma_report/releases/download/current/years_since_fire.tif .The mean current NDVI layer is available at https://github.com/AdamWilsonLab/emma_envdata/releases/download/current/mean_ndvi.tif .\n\n## Area burned and vegetation ages\n\n```{r vegetation ages over time, fig.width = 10, fig.height = 7, echo = FALSE, warning = FALSE, message = FALSE}\n\n# Subset park_fire_history to only the focal park\n\n  # use the ndvi raster as a template to get cells in park\n\n    most_recent_ndvi.tif %>%\n      terra::extract(y = vect(focal_park),\n                     cells = TRUE,\n                     touches = TRUE) %>%\n    dplyr::select(cell) -> focal_cells\n\n  # subset fire data\n\n  focal_fires <-\n    park_fire_history %>%\n    filter(cellID %in% focal_cells$cell)\n  \n  \n  # if empty, fill in NAs\n  \n    if(nrow(focal_fires) == 0){\n      \n      focal_fires <- expand.grid(cellID = focal_cells$cell,\n                                 date = unique(park_fire_history$date),\n                                 days_since_fire = NA)  \n      \n      \n    }\n  \n    \n  # dealing with missing cells/ages\n  \n    focal_fires %>%\n      pivot_wider(names_from = date,\n                  values_from = days_since_fire) %>%\n      full_join(y = focal_cells,\n                by = c(\"cellID\"=\"cell\")) %>%\n      pivot_longer(cols = !1, # make sure this ncol is pointing to the correct thing\n                   names_to = \"date\",\n                   values_to = \"days_since_fire\") %>%\n                mutate(cellID = as.factor(cellID),\n                       years_since_fire = days_since_fire/365.25,\n                       date =as.numeric(date))%>%\n                    mutate(date = as_date(date),\n                       year = year(date))%>%\n      mutate(years_since_fire = case_when(is.na(years_since_fire) ~ 20,\n                                          years_since_fire >= 0 ~ years_since_fire,\n                                          years_since_fire < 0 ~ 20)) -> ff2\n  \n        \nff2 %>%\n  mutate(gte20 = years_since_fire >= 20) %>%\n  group_by(year,gte20) %>%\n  count()%>%\n  ungroup()%>%\n  group_by(year)%>%\n  mutate(total=sum(n))%>%\n  mutate(fraction = n/total)%>%\n  filter(gte20)-> unburned_summary        \n        \nff2 %>%\n  filter(years_since_fire<20)%>%\n  mutate(year=as.factor(year))%>%\nggplot(mapping = aes(x=years_since_fire,\n                     y=year,\n                     fill=after_stat(x)))+\n  geom_density_ridges_gradient()+\n  labs(fill = \"Age\")+\n  xlab(\"Vegetation Age Distribution\")+\n  ylab(\"Year\")+\n  theme_bw()+\n  theme(legend.position = \"none\")+\n  geom_text(data = unburned_summary,\n            aes(label = paste(round(fraction,2)*100,\"%\"),\n                y=as.factor(year),\n                x = max(ff2$years_since_fire)), \n            position = position_stack(),\n            inherit.aes = F)+\n  scale_y_discrete(expand = c(.05, 0.2))+\n  coord_flip() -> p1\n        \n\nfocal_fires |> \n  mutate(year=year(as_date(date))) |> \n  group_by(year) |> \n  summarize(area_burned=sum(ifelse(days_since_fire<45,1,0))) |>\n  ggplot(aes(x=year,y=area_burned))+\n  geom_line()+\n  ylab(\"Area Burned\")+\n  xlab(\"\")+\n   scale_x_continuous(\n      breaks = seq(min(year(as_date(focal_fires$date))), max(year(as_date(focal_fires$date))), by = 1)) ->  # One tick per year\n  p_burnedarea\n\nplot_grid(p_burnedarea, p1, ncol=1, align = \"v\", labels = \"AUTO\",rel_heights = c(0.3,0.7),label_size = 0) \n     \n```\n\nFigure 2. Top: Total area burned each year in the park.  Bottom: Ridgeplot histogram showing vegetation age distributions within the park over time. Percentages shown represent amount of vegetation that is 20 years old or older. Note that areas where fires are not known to have occurred have been assigned a vegetation age of 20 years.\n\n\n```{r vegetation ages, fig.width = 10, fig.height = 7, echo = FALSE, warning = FALSE, message = FALSE, eval=F}\n  \n## Current Vegetation Age Distribution\n\n  # set NA values to 21 (we'll reset anything higher than 20 to 20+ for visualization)\n  # mask years since fire raster to the park\n\n  ysf_masked <- years_since_fire.tif\n  ysf_masked[is.na(ysf_masked)] <- 21\n  ysf_masked %>%\n  mask(focal_park) -> ysf_masked\n\n  # library(tidyterra)\n  # ggplot()+\n  #   geom_sf(data = focal_park)+\n  #   geom_spatraster(data = ysf_masked %>%\n  #                     crop(ext(focal_park)),\n  #                   mapping = aes(fill = lyr.1))+\n  #   coord_sf(crs=crs(ysf_masked))+\n  #   scale_fill_terrain_c()\n  \n  data.frame(Vegetation_Age = values(ysf_masked) %>%\n               as.vector()) %>%\n    filter(!is.na(Vegetation_Age)) %>%\n    mutate( Vegetation_Age = case_when(Vegetation_Age > 20 ~ 20,\n                                       .default = Vegetation_Age)) %>%\n    mutate(Vegetation_Age = round(x = Vegetation_Age, digits = 2))-> test\n  \n  \n    km2_per_pixel <- res(ysf_masked)[1]*res(ysf_masked)[2]*1e-6\n    \n    \n    \n    test %>%\n    ggplot(mapping = aes(x = Vegetation_Age))+\n    geom_histogram()+\n    xlab(\"Vegetation Age (years)\")+\n    scale_x_continuous(breaks = c(0,5,10,15,20),\n    labels = c(0,5,10,15,\"20(+)\"),\n    limits = c(0,21),\n    expand = c(0,0))+\n      #convert to km2\n    scale_y_continuous(expand = c(0,0),\n                       labels = function(x){\n                         round(x * res(ysf_masked)[1] * res(ysf_masked)[2] * 1e-6,\n                                                  digits = 0)})+\n      ylab(expression(paste(\"Area \", (km^2) )))+\n    theme_bw()\n    \n\n    \nFigure 3. Histogram of vegetation ages. For the purposes of this plot, any vegetation known to either be 20 years old or older, or for which we have no recorded records of fire, has been assigned an age of 20(+) years. The area shown was calculated by mutliplying counts of MODIS pixels at each age with the area of each pixel in square kilometers.\n\n\n\n```\n\n\n## Weather Data\n\n```{r weatherdyplot, echo=FALSE, message=FALSE, warning=FALSE}\n\n  # see: https://rstudio.github.io/dygraphs/\n\n# Define a shared group name\nshared_group <- \"weather_group\"\n\nfocal_precip_df <- as.data.frame(focal_precip) |> \n   mutate(across(where(is.numeric) & !any_of(\"date_time\"), function(x) log1p(ifelse(x<0.001,0,x))))\n\nfocal_precip_trans <- ts(focal_precip_df,\n                         start = start(focal_precip),\n                         frequency = frequency(focal_precip))\n\ndygraph(focal_precip_trans,\n        main = \"Precipitation (log1p-transformed)\",\n        xlab = \"Date\",\n        ylab = \"log1p(Precip mm)\",\n       group = shared_group) %>%\n      dyAxis(\"y\",\n         label = \"Precip. (mm)\",\n         axisLabelFormatter = JS(\n           \"function(value, granularity, opts, dygraph) {\n              return Math.round(Math.exp(value) - 1);\n            }\"\n         ),\n         valueFormatter = JS(\n    \"function(num, opts, seriesName, g, row, col) {\n       return (Math.exp(num) - 1).toFixed(2);\n     }\"\n  ))  |> \n  dySeries() %>%\n  dyRangeSelector() ->\n  precip_graph\n\n\n      dygraph(data = focal_mean_daily_temp[,colnames(focal_mean_daily_temp)[which(colnames(focal_mean_daily_temp)!=\"date_time\")]],\n          main = \"Temperature\",\n          xlab = \"Date\",\n          ylab = \"Temp. (C)\",\n          group = shared_group) %>%\n    dySeries() %>%\n    dyRangeSelector(dateWindow = c( Sys.Date() - time_window_days, Sys.Date())) -> mean_temp_graph\n\n```\n\n```{r plot_precip, echo=F, eval = TRUE, message = F, fig.width = 10, fig.height = 6}\n#| fig-cap: \n#|   - \"Figure 4. Climate Data from GSOD.  Mean data is a long-term average for each day of the year across these weather stations.\"\n  #This code chunk plots the targets visualization.\n  # I do this in two steps to avoid errors that otherwise can occur\n\n  precip_graph\n\n```\n\n```{r plot_temp, echo=F, eval = TRUE, message = F, fig.width = 10, fig.height = 6}\n#| fig-cap: \n#|   - \"Figure 5. Climate Data from GSOD.  Mean data is a long-term average for each day of the year across these weather stations.\"\n\n\n  #This code chunk plots the targets visualization.\n  # I do this in two steps to avoid errors that otherwise can occur\n\n  #temp_graph\n  mean_temp_graph\n\n```\n\n## Drought Indices\n\n```{r NDWI_plot, fig.width = 10, fig.height = 7, echo = FALSE, warning = FALSE, message = FALSE, eval=FALSE, include=FALSE}\n  leaflet(data = focal_wgs) %>%\n  addProviderTiles(\"Esri.NatGeoWorldMap\", group = \"NatGeo\") %>%\n    #addProviderTiles(\"NASAGIBS.ModisTerraTrueColorCR\", group = \"True Colors\") %>%\n    addProviderTiles(providers$Esri.WorldImagery, group = \"World Imagery\") %>%\n  addPolygons(color = \"black\",\n              stroke = TRUE,\n              fill = FALSE,\n              group = \"Park\") %>%\n  addRasterImage(x = ndwi_rast,\n                 group = \"NDWI\",\n                 #colors = ndwi_pal\n                 colors = ndwi_bin_pal,\n                 opacity = 0.8\n                 )%>% \n  addMouseCoordinates() %>%\n      addImageQuery(ndwi_rast, type=\"mousemove\", layerId = \"NDWI\") %>%\n  leaflet::addLegend(position = \"bottomright\",\n            #pal = ndwi_pal,\n            pal = ndwi_bin_pal,\n            values = ~values(ndwi_rast),\n            opacity = 1,\n            title = \"NDWI\") %>%\n    addLayersControl(\n    baseGroups = c(\"NatGeo\",\"World Imagery\"),\n    overlayGroups = c(\"NDWI\", \"Park\"),\n    options = layersControlOptions(collapsed = FALSE),position = \"topright\") %>%\n  fitBounds(bbox[1], bbox[2], bbox[3], bbox[4])\n\n# Below is the text that accompanies this figure  \n#   Figure 6. The Normalized Difference Water Index [(NDWI)](https://en.wikipedia.org/wiki/Normalized_difference_water_index) is a measure of the water content of leaves ranging between -1 (no water) and 1 (water). The NDWI data were last updated on `r most_recent_ndwi_date` (although they may be older than the update date).\n# \n# Interpreting NDWI:\n# \n#   * 1 - 0.2 = Water surface,\n#   * 0.2 – 0.0 = Flooding, humidity,\n#   * 0.0 – -0.3 = Moderate drought, non-aqueous surfaces,\n#   * -0.3 – -1 = Drought, non-aqueous surface\n\n  \n\n```\n\n### SPI\n\nThe Standardized Precipitation Index [(SPI)](https://gmao.gsfc.nasa.gov/research/subseasonal/atlas/SPI-html/SPI-description.html#:~:text=The%20SPI%20is%20used%20for,from%20subseasonal%20to%20interannual%20scales.) is a drought index ranging from -3 (very dry) to +3 (very wet).\n\n```{r calc_spi_1, eval = TRUE, fig.width = 10, fig.height = 7, echo = FALSE, warning = FALSE, message = FALSE}\n\n  #Make a dataset with only mostly complete data\n\n  stations_to_keep <-\n    bind_cols(date_time=time(focal_precip_monthly_xts),focal_precip_monthly_xts)%>%\n    pivot_longer(cols = !date_time,\n                 names_to = \"station_name\",\n                 values_to = \"monthly_precip_mm\") %>%\n    group_by(station_name) %>% \n    summarize(fraction_na = sum(is.na(monthly_precip_mm))/length(monthly_precip_mm)) %>% \n    filter(fraction_na < 0.05) %>%\n    dplyr::select(station_name)\n\n  \n  focal_precip_monthly_xts %>%\n     as.data.frame() %>%\n    .[stations_to_keep$station_name] %>%\n     mutate_if(is.character, as.numeric) -> focal_spi_data\n\n  \n  # Only use the mean estimates if those are the only complete ones\n\n    #focal_spi_data %>%\n    #dplyr::select(!mean) -> focal_spi_data\n      \n      \n    if(ncol(focal_spi_data)>0){\n  \n      spi_window=6 # number of months of moving window\n\nspi <- spi(data = ts(focal_spi_data,\n                           frequency = 12,\n                           start = c(rownames(focal_spi_data)[1]%>%\n                                       substr(start = 0,stop = 4),\n                                     rownames(focal_spi_data)[1]%>%\n                                       substr(start = 6,stop = 7))),\n                 scale =  spi_window,\n                 verbose = FALSE,\n                 na.rm = TRUE)\n\nspi2 <- as_tibble(spi$fitted) %>%\n  mutate(date = as.Date(as.yearmon(time(spi$fitted)))) %>%\n  relocate(date) %>%\n  pivot_longer(-date, names_to = \"station\", values_to = \"spei\") #|> \n # mutate(       # Create a new column to separate positive and negative SPEI\n#    spei_pos = ifelse(spei > 0, spei, 0),\n#    spei_neg = ifelse(spei < 0, spei, 0)\n#  )\n\n\n\n\n    }\n      \n```\n\n```{r spiplot, eval = TRUE, fig.width = 10, fig.height = 10, echo = FALSE, warning = FALSE, message = FALSE}\n\n  if(ncol(focal_spi_data)>0){\n\n# # Plot with separate fill colors for positive and negative values\n# ggplot(spi2, aes(x = date)) +\n#   geom_hline(yintercept = 0, color = grey(0.6)) +\n# #  geom_line(aes(y = spei), col=\"transparent\") + #for plotly to return simple value?\n#   geom_area(aes(y = spei_pos), fill = \"darkblue\") +\n#   geom_area(aes(y = spei_neg), fill = \"darkred\") +\n#   geom_smooth(aes(y = spei), span = 0.2, se = TRUE,col=\"black\") +\n#   ggtitle(\"6 Month Standardized Precipitation Index (SPI)\") +\n#   ylab(\"Standardized Precipitation Index (SPI)\")+\n#   xlab(\"Date\") +\n#   facet_wrap(~station,ncol=1)+\n#       coord_equal(ratio = 100)+\n#   theme_minimal()  -> p_spi\n#   \n#     #ggplotly(p_spi,layerData = 2)\n#      p_spi\n#   }\n\n\n# Plot with separate fill colors for positive and negative values\nggplot(spi2, aes(x = date)) +\n  geom_hline(yintercept = 0, color = grey(0.6)) +\n  geom_line(aes(y = spei,col=station)) + \n  geom_smooth(aes(y = spei), span = 0.3, se = TRUE,col=\"black\") +\n  ggtitle(paste0(\"Standardized Precipitation Index (SPI with \",spi_window,\" Month window)\")) +\n  scale_color_viridis_d()+\n  ylab(\"Standardized Precipitation Index (SPI)\")+\n  xlab(\"Date\") +\n  theme_minimal()  -> p_spi\n\n    p_spi\n    \n    spi2 |> \n      pivot_wider(names_from = station,values_from = spei) |> \n      dygraph(\n          main = \"Standardized Precipitation Index (SPI with 6 Month window)\",\n          xlab = \"Date\",\n          ylab = \"SPI\",\n          group = shared_group) %>%\n    dySeries() %>%\n    dyRangeSelector(dateWindow = c( Sys.Date() - time_window_days, Sys.Date())) -> spi_graph\n    \n    \n  spi_graph\n    \n}\n```\n\n# Report Metadata\n\nThis table summarizes the date this report was generated and the most recent observation for each data type.\n\n```{r, echo=F, results='asis'}\n# build table of dates when products were last updated\n\ndates <- bind_rows(\n  data.frame(Description = \"Website\", Date = format(now(), \"%Y-%b-%d\")),\n  data.frame(Description = \"NDVI\", Date = format(most_recent_ndvi_date, \"%Y-%b-%d\")),\n  data.frame(Description = \"Weather\", Date = format(max(focal_weather$date_time), \"%Y-%b-%d\"))\n) |> \n  select(Description, \"Date last updated\"=Date)\n\nknitr::kable(dates)\n \n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../styles.css"],"toc":true,"output-file":"Driftsands_Nature_Reserve.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.31","theme":"cosmo","title":"Park Report","params":{"focal_park_name":"Driftsands Nature Reserve"}},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}